# 自旋锁spin_lock、spin_lock_irq以及spin_lock_irqsave的区别

转载：https://www.byteisland.com/%e8%87%aa%e6%97%8b%e9%94%81-spin_lock%e3%80%81-spin_lock_irq-%e4%bb%a5%e5%8f%8a-spin_lock_irqsave-%e7%9a%84%e5%8c%ba%e5%88%ab/

能够停留下来认真读这篇文章的人大部分都已经了解了什么是自旋锁，至少知道自选锁就是不停的询问资源有没有准备好的一把锁，这个从概念上很容易理解，当然他的内在也是很容易实现。

## 1. 为什么需要自旋锁

很多时候我们并不能采用其他的锁，比如读写锁、互斥锁、信号量等。一方面这些锁会发生上下文切换，他的时间是不可预期的，对于一些简单的、极短的临界区完全是一种性能损耗；另一方面在中断上下文中时不允许睡眠的，除了自旋锁意外的其他任何形式的锁都有可能导致睡眠或者进程切换，这是违背了中断的设计初衷，会发生不可预知的错误。基于两点，我们需要自旋锁，他是不可替代的。

## 2. 为什么自旋锁会禁止抢占

这一点其实很好理解，当一个CPU获取到一把自旋锁之后，开始执行临界区代码，此时假设他的时间片运转完毕，进程调度会主动触发调度将其调走，执行另一个线程/进程，结果恰巧了这个线程/进程也需要用到该自旋锁，而上一个线程/进程还在停留在临界区内未释放锁，导致本进程无法获取到锁而形成死锁，所以自旋锁为了规避此类情形的出现从而直接禁止对已经开始运行的临界区设置禁止抢占标志。

### 3. 为什么临界区禁止睡眠

如果自旋锁锁住以后进入睡眠，而此时又不能进行处理器抢占，内核的调取器无法调取其他进程获得该CPU，从而导致该CPU被挂起；同时该进程也无法自唤醒且一直持有该自旋锁，进一步会导致其他使用该自旋锁的位置出现死锁。

## 4. spin_lock系列的分别

每一种锁出现都有自己的原因，spin_lock系列的锁就是为了解决这一个又一个的问题才会新增的各种自旋锁变种，这也符合现代计算机代码设计逻辑，首先是解决有无问题之后再解决崩溃问题，最后才是性能问题，没有什么设计能够逃得出这样一个框架。

spin_lock出现的原因上文已经介绍过了，目标就是为了解决当前内核中，某些场景下快速访问临界区的问题而存在的，所以他禁止了调度器抢占，所以不存在任何其他的进程会抢占该CPU的情况。但是，现代计算机为了能够更快的响应各种外部消息，所以存在各种类型的中断，比如网卡中断的到来，就一定会打断正在执行的CPU进程，哪怕是当前的程序被spin_lock给锁住了，假设当前的中断也需要访问该spin_lock锁，那么就会导致死锁发生，如图：

![spin_lock_irq](.\自旋锁_image\spin_lock_irq.png)

所以为了应对自旋锁同时出现在硬件中断和进程上下文的情况，所以应该在进程执行临界区代码段的自旋锁上锁之前，首先就应该关闭当前CPU的中断，这样无论你发生什么情况，一旦被锁上就不再会被任何的情况抢走CPU，这就是spin_lock_irq出现的原因，当然，由于需要关闭中断，会导致系统的响应降低，而且还会执行更多的代码，可能会导致性能下降。

那么spin_lock_irqsave又为何需要存在，之前说过每一种类型变种的出现都是为了解决实际问题，那么这个类型锁的出现也是为了解决一些实际问题。如图所示：

![spin_lock_irqsave](.\自旋锁_image\spin_lock_irqsave.png)

从图中可以看出，当进程在执行第一个spin_lock_irq(&lock1)时已经关闭了中断，然后继续获取第二个自旋锁spin_lock_irq(&lock2)，当lock2解锁后且lock1未解锁前这一段区域处于一种硬件中断开启的状态，这段代码仍然处于lock1的临界区，如果此时硬件中断也需要申请lock1锁会导致死锁，这是因为spin_unlock_irq在解锁时一定会将本地CPU的中断打开，从而导致硬件中断可以重新强制抢占CPU，所以最好的方式就是lock2在锁之前保存当前的中断状态，在解锁时恢复当前的中断状态，这也就是spin_lock_irqsave需要存在的原因。自然地，这是一种更为线程安全的方案，但是他会带来比前面几种更加多的性能损耗。

